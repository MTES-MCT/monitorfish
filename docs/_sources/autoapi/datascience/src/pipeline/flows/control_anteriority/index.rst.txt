:py:mod:`datascience.src.pipeline.flows.control_anteriority`
============================================================

.. py:module:: datascience.src.pipeline.flows.control_anteriority


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   datascience.src.pipeline.flows.control_anteriority.compute_control_dates_coefficients
   datascience.src.pipeline.flows.control_anteriority.compute_control_ranks_coefficients
   datascience.src.pipeline.flows.control_anteriority.extract_last_years_controls
   datascience.src.pipeline.flows.control_anteriority.extract_fishing_infraction_ids
   datascience.src.pipeline.flows.control_anteriority.get_last_controls
   datascience.src.pipeline.flows.control_anteriority.compute_control_rate_risk_factors
   datascience.src.pipeline.flows.control_anteriority.compute_infraction_rate_risk_factors
   datascience.src.pipeline.flows.control_anteriority.merge
   datascience.src.pipeline.flows.control_anteriority.load_control_anteriority



Attributes
~~~~~~~~~~

.. autoapisummary::

   datascience.src.pipeline.flows.control_anteriority.control_rate_bins
   datascience.src.pipeline.flows.control_anteriority.control_rate_bins_risk_factors
   datascience.src.pipeline.flows.control_anteriority.infraction_rate_bins
   datascience.src.pipeline.flows.control_anteriority.controls


.. py:data:: control_rate_bins
   

   

.. py:data:: control_rate_bins_risk_factors
   

   

.. py:data:: infraction_rate_bins
   

   

.. py:function:: compute_control_dates_coefficients(control_dates: pandas.Series, from_date: datetime.datetime, to_date: datetime.datetime) -> pandas.Series

   For each date in ``control_dates``, computes a coefficient determined by its
   distance from ``from_date`` relative to the distance between ``from_date`` and
   ``to_date``.

   :param control_dates: Series of ``datetime.datetime``
   :type control_dates: pd.Series
   :param from_date: Start of time interval considered
   :type from_date: datetime
   :param to_date: Start of time interval considered
   :type to_date: datetime

   :returns: [description]
   :rtype: pd.Series

   .. rubric:: Examples

   >>> import pandas as pd
   >>> from datetime import datetime
   >>> from_date = datetime(2021, 1, 1)
   >>> to_date = datetime(2023, 1, 1)
   >>> dates = pd.Series([
               datetime(2019, 6, 5),
               datetime(2021, 1, 1),
               datetime(2022, 1, 1),
               datetime(2025, 5, 2)
       ])
   >>> compute_control_dates_coefficients(
               dates,
               from_date=from_date,
               to_date=to_date
       )
   0    0.0
   1    0.0
   2    0.5
   3    0.0
   dtype: float64


.. py:function:: compute_control_ranks_coefficients(control_ranks: numpy.array) -> numpy.array

   Given a ``numpy.array`` of integers representing the rank of vessels controls
   over time, returns the corresponding coefficients with which they must be taken
   into account in the risk factor.

   The input array represents the controls of several vessels. For each vessel,
   controls are sorted from most to least recent and ranked (1, 2, 3...).

   The output is an array with the same shape which contains coefficients defined as:

     * 1.0 for controls of rank 1
     * 0.9 for controls of rank 2
     * ...
     * 0.1 for controls of rank 10
     * 0.0 for controls of rank 11+

   :param control_ranks: 1D-array of integers >= 1
   :type control_ranks: np.array

   :returns: array with the same shape and with coefficients between 1 (for
             controls of rank 1) and 0 (for controls of rank >= 10).
   :rtype: np.array

   .. rubric:: Examples

   >>> ranks = np.array([1, 4, 2, 2, 12, 2, 4])
   >>> compute_control_ranks_coefficients(ranks)
   np.array([1.0, 0.7, 0.9, 0.9, 0.0, 0.9, 0.7])


.. py:function:: extract_last_years_controls(years: float = 5) -> pandas.DataFrame

   Extracts controls data of the last ``years`` years for all vessels.

   :param years: Number of years to extract. Defaults to 5.
   :type years: float, optional

   :returns: all vessels' controls data for the last years
   :rtype: pd.DataFrame


.. py:function:: extract_fishing_infraction_ids() -> set

   Extracts all ``ids`` of ``infractions`` related to fishing non-compliance
   (safety non compliance events are excluded).

   :returns: Set of infractions ids related to fishing
   :rtype: set


.. py:function:: get_last_controls(controls: pandas.DataFrame) -> pandas.DataFrame

   Filters the input ``pd.DataFrame`` of controls data to keep only

   * the most recent control of each vessel
   * the following columns:

     * ``vessel_id``
     * ``cfr``
     * ``ircs``
     * ``external_immatriculation``
     * ``control_datetime_utc``
     * ``infraction``
     * ``post_control_comments``

   :param controls: ``pd.DataFrame`` with controls data
   :type controls: pd.DataFrame

   :returns: filtered input with only the most recent control of each vessel
             and a subset of columns
   :rtype: pd.DataFrame


.. py:function:: compute_control_rate_risk_factors(controls: pandas.DataFrame) -> pandas.DataFrame

   Given controls data on 3+ years, computes the control rate risk factor of each
   vessel.

   The idea is that vessels that have been controlled less over the past 3 years and
   that have not been controlled for a certain time have a higher priority of control
   than vessels that were controlled many times over the past 3 years and that were
   controlled recently.

   :param controls: ``pd.DataFrame`` of controls data on the last 3+ years
   :type controls: pd.DataFrame

   :returns: for each vessel, the component of the risk factor related to the
             control rate of each vessel.
   :rtype: pd.DataFrame


.. py:function:: compute_infraction_rate_risk_factors(controls: pandas.DataFrame, fishing_infraction_ids: set) -> pandas.DataFrame

   Given control results data of vessels over the past 3+ years, computes the
   infraction rate risk factor of each vessel.

   The idea is that vessels which committed infractions in the past have a higher
   priority of control than vessels that were in order.

   Only violations related to fishing non-compliance are taken into account. Safety
   non-compliance evens are not taken into account.

   :param controls: control results data
   :type controls: pd.DataFrame
   :param fishing_infraction_ids: set of infractions ids related to fishing
                                  non-compliance.
   :type fishing_infraction_ids: set

   :returns: for each vessel, the component of the risk factor related to the
             infraction rate of each vessel.
   :rtype: pd.DataFrame


.. py:function:: merge(control_rate_risk_factors: pandas.DataFrame, infraction_rate_risk_factor: pandas.DataFrame, last_controls: pandas.DataFrame) -> pandas.DataFrame

   Merge of ``pd.DataFrame``s to produce output of the flow. The join is performed
   on ``vessel_id``.

   :param control_rate_risk_factors: output of
   :type control_rate_risk_factors: pd.DataFrame
   :param ``compute_control_rate_risk_factors`` task:
   :param infraction_rate_risk_factor: output of
   :type infraction_rate_risk_factor: pd.DataFrame
   :param ``compute_infraction_rate_risk_factors`` task:
   :param last_controls: output of ``get_last_controls`` task
   :type last_controls: pd.DataFrame

   :returns: join of the 3 input ``pd.DataFrame``s
   :rtype: pd.DataFrame


.. py:function:: load_control_anteriority(control_anteriority: pandas.DataFrame)

   Load the output of ``merge`` task into ``control_anteriority`` table.

   :param control_anteriority: output of ``merge`` task.
   :type control_anteriority: pd.DataFrame


.. py:data:: controls
   

   

